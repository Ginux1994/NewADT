## 12-10 完成：
#### 上午：
* 1. 三维纯热传导，加固定温度载荷===》意味着，先写好**固定温度载荷下的右端项计算函数**
* 2. 热传导+线性对流，能把两个刚度矩阵加对，也即测试多矩阵刚度矩阵总装的程序正确性，同时能写出来  **对流单元，对流载荷函数**

####下午：
* 3. 热传导+热生成+线性对流，写上**热生成部分的函数，并能保证右端项的争取累加**


* 终于弄清楚热流载荷步的信息存取方案了，ADINA将 集中热流输入 按照载荷步，写入到 文件10 中，每个载荷步包含了每个节点的温度值，可以开一个 nstep*nequation的数组 放置集中热流信息， 且将固定温度、对流、辐射的热流数据都放在 文件13 中，同样按照载荷步的大顺序， 每个数据块分别放温度、对流、辐射，且不同于集中热流，存所有节点的，而是只存受载荷的节点信息。
* ADINA通过文件来实现载荷步数据的更新的原理 很简单也很巧妙，通过维护多个文件IO，每个载荷步iper读取完，都会停留在上次读取的位置，而到了下个载荷步，必然会继续往下读，而不是向我之前想的那样，一次抓取整个文件，这样多浪费时间撒。。但对于我来说就没必要这么做了，完全可以把这些信息存放在公共数组中。。不过后面也可以扩展很容易啦。。
* 这应该就是老代码的精髓了非常巧妙地用外存==芯外存储，来节省内存空间，从而实现大规模计算。如此紧凑高效的代码真的让人感动啊..现在也大概能够猜到老人们是怎么通过几K内存实现大规模计算的啦
* 最核心的应该是time，时间驱动着这个迭代，而不是收敛误差，时间让迭代有条不紊的走下去，而tolerance只是其中一环一环的纽带。  用time去驱动这个架构，想象她为一个真实的过程，一点一点的步进